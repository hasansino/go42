name: generate-summary

# Reusable workflow for generating summaries using OpenAI API
# Can be used for releases, PRs, or any commit range

on:
  workflow_call:
    inputs:
      base_ref:
        description: 'Base reference (branch, tag, or commit SHA)'
        required: true
        type: string
      head_ref:
        description: 'Head reference (branch, tag, or commit SHA)'
        required: true
        type: string
      context_type:
        description: 'Context type for summary (release, pr, custom)'
        required: false
        type: string
        default: 'custom'
      llm_model:
        description: 'OpenAI model to use for summary generation'
        required: false
        type: string
        default: 'gpt-4o-mini'
      debug:
        description: 'Enable debug output'
        required: false
        type: boolean
        default: false
    outputs:
      summary:
        description: 'Generated summary markdown'
        value: ${{ jobs.generate.outputs.summary }}
      comparison_url:
        description: 'GitHub comparison URL'
        value: ${{ jobs.generate.outputs.comparison_url }}
    secrets:
      OPENAI_API_KEY:
        description: 'OpenAI API key for summary generation'
        required: true

permissions: {}

jobs:
  generate:
    name: generate-summary
    runs-on: ubuntu-latest
    outputs:
      summary: ${{ steps.generate_summary.outputs.summary }}
      comparison_url: ${{ steps.urls.outputs.comparison_url }}
    steps:
      - name: Checkout repository with full history
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: Generate URLs and metadata
        id: urls
        run: |
          # Generate comparison URL
          echo "comparison_url=https://github.com/${{ github.repository }}/compare/${{ inputs.base_ref }}...${{ inputs.head_ref }}" >> "$GITHUB_OUTPUT"
          
      - name: Generate Summary with OpenAI
        id: generate_summary
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          LLM_MODEL: ${{ inputs.llm_model }}
          BASE_REF: ${{ inputs.base_ref }}
          HEAD_REF: ${{ inputs.head_ref }}
          CONTEXT_TYPE: ${{ inputs.context_type }}
        run: |
          # Validate OpenAI API key
          if [ -z "$OPENAI_API_KEY" ]; then
            echo "::error::OPENAI_API_KEY is not set in repository secrets"
            echo "summary=" >> "$GITHUB_OUTPUT"
            exit 1
          fi
          
          # Get commit messages between refs with clickable hashes and authors
          echo "Fetching commits between $BASE_REF and $HEAD_REF..."
          # Get commits with hash, author email, and message
          COMMITS_RAW=$(git log --pretty=format:"%h|%ae|%s" "$BASE_REF".."$HEAD_REF" 2>/dev/null || echo "")
          
          # Convert to markdown with clickable links and author info
          COMMITS=""
          while IFS= read -r line; do
            if [ -n "$line" ]; then
              HASH=$(echo "$line" | cut -d'|' -f1)
              AUTHOR=$(echo "$line" | cut -d'|' -f2 | cut -d'@' -f1)  # Extract username from email
              MESSAGE=$(echo "$line" | cut -d'|' -f3-)
              COMMITS="${COMMITS}- ${MESSAGE} ([${HASH}](https://github.com/${{ github.repository }}/commit/${HASH})) by @${AUTHOR}\n"
            fi
          done <<< "$COMMITS_RAW"
          
          # Remove trailing newline
          COMMITS=$(echo -e "$COMMITS" | sed '$ s/.$//')
          
          if [ -z "$COMMITS" ]; then
            echo "No commits found between refs"
            echo "summary=" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          
          # Count different types of changes
          FEATURES=$(echo "$COMMITS" | grep -c -E "^- (feat|feature):" || echo "0")
          FIXES=$(echo "$COMMITS" | grep -c -E "^- (fix|bugfix):" || echo "0")
          BREAKING=$(echo "$COMMITS" | grep -c -E "^- (breaking|BREAKING CHANGE):" || echo "0")
          TOTAL=$(echo "$COMMITS" | grep -c "^-" || echo "0")
          
          # Trim any whitespace/newlines from counts
          FEATURES=$(echo "$FEATURES" | xargs)
          FIXES=$(echo "$FIXES" | xargs)
          BREAKING=$(echo "$BREAKING" | xargs)
          TOTAL=$(echo "$TOTAL" | xargs)
          
          # Ensure variables are proper integers
          FEATURES=${FEATURES//[^0-9]/}
          FIXES=${FIXES//[^0-9]/}
          BREAKING=${BREAKING//[^0-9]/}
          TOTAL=${TOTAL//[^0-9]/}
          
          # Default to 0 if empty
          FEATURES=${FEATURES:-0}
          FIXES=${FIXES:-0}
          BREAKING=${BREAKING:-0}
          TOTAL=${TOTAL:-0}
          
          # Customize prompt based on context type
          case "$CONTEXT_TYPE" in
            "release")
              CONTEXT_PROMPT="Generate a concise and professional release summary for version $HEAD_REF based on the following git commits."
              ;;
            "pr")
              CONTEXT_PROMPT="Generate a concise pull request description based on the following git commits. Focus on what changes are being made and why."
              ;;
            *)
              CONTEXT_PROMPT="Generate a concise summary of changes based on the following git commits."
              ;;
          esac
          
          # Prepare the prompt for LLM
          PROMPT=$(cat <<EOF
          $CONTEXT_PROMPT
          
          Statistics:
          - Total commits: $TOTAL
          - Features: $FEATURES
          - Bug fixes: $FIXES
          - Breaking changes: $BREAKING
          
          Commits:
          $COMMITS
          
          Requirements:
          1. ONLY output two sections: "Highlights" and a list of changes grouped by type
          2. Do NOT include an overview paragraph or any other sections
          3. Keep the Highlights section to 2-3 most important changes only
          4. Group all changes by type (Features, Bug Fixes, Breaking Changes, Other Changes)
          5. Use bullet points for each change
          6. IMPORTANT: Preserve the commit hash links and author information from the original commits
          7. Each commit line MUST include the clickable hash link and "by @author" at the end
          8. Keep descriptions clear and user-focused
          9. If there are breaking changes, make them prominent
          10. Do not use any emojis
          11. Keep the total summary concise
          12. Use markdown formatting
          
          Template:
          ### Highlights
          - [Most important change 1]
          - [Most important change 2]
          
          ### Features
          - [New features]
          
          ### Bug Fixes
          - [Fixed issues]
          
          ### Breaking Changes (if any)
          - [Breaking changes with migration notes]
          
          ### Other Changes (if any)
          - [Other notable changes]
          EOF
          )
          
          # Generate summary using OpenAI API
          echo "Generating summary using OpenAI API with model: $LLM_MODEL"
          
          # Check if model is premium
          PREMIUM_MODELS=("gpt-4" "gpt-4-turbo" "gpt-4o" "o1-preview" "o1-mini")
          IS_PREMIUM=false
          for model in "${PREMIUM_MODELS[@]}"; do
            if [[ "$LLM_MODEL" == *"$model"* ]]; then
              IS_PREMIUM=true
              break
            fi
          done
          
          if [ "$IS_PREMIUM" = true ]; then
            echo "::warning::Using premium model '$LLM_MODEL'. This will incur higher API costs."
          else
            echo "Using standard model '$LLM_MODEL'"
          fi
          
          # Prepare JSON payload for OpenAI API
          JSON_PAYLOAD=$(jq -n \
              --arg model "$LLM_MODEL" \
              --arg prompt "$PROMPT" \
              '{
                "model": $model,
                "messages": [
                  {
                    "role": "system",
                    "content": "You are a helpful assistant that generates professional summaries for software projects. Be concise and clear. ONLY output the Highlights section and the grouped list of changes. Do NOT include any overview paragraphs or additional commentary. IMPORTANT: You MUST preserve the commit hash links in format ([hash](url)) and author information (by @author) from each commit line exactly as provided."
                  },
                  {
                    "role": "user", 
                    "content": $prompt
                  }
                ],
                "temperature": 0.7,
                "max_tokens": 1000,
                "stream": false
              }')
          
          if [ "${{ inputs.debug }}" = "true" ]; then
            echo "::debug::API Request payload:"
            echo "$JSON_PAYLOAD" | jq '.'
          fi
          
          # Call OpenAI API
          API_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "https://api.openai.com/v1/chat/completions" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -d "$JSON_PAYLOAD")
          
          # Extract HTTP status code and response body
          HTTP_CODE=$(echo "$API_RESPONSE" | tail -n1)
          RESPONSE_BODY=$(echo "$API_RESPONSE" | sed '$d')
          
          if [ "${{ inputs.debug }}" = "true" ]; then
            echo "::debug::HTTP Response Code: $HTTP_CODE"
            echo "::debug::API Response (first 1000 chars):"
            echo "${RESPONSE_BODY:0:1000}"
          fi
          
          # Check HTTP status code
          if [ "$HTTP_CODE" != "200" ]; then
            echo "::warning::OpenAI API returned HTTP $HTTP_CODE"
            if [ "$HTTP_CODE" = "429" ]; then
              echo "::warning::Rate limit exceeded. Using fallback."
            elif [ "$HTTP_CODE" = "401" ]; then
              echo "::warning::Authentication failed. Check if OPENAI_API_KEY is valid."
            elif [ "$HTTP_CODE" = "403" ]; then
              echo "::warning::Access forbidden. Check API key permissions."
            fi
          fi
          
          # Check if response contains an error
          ERROR_MESSAGE=$(echo "$RESPONSE_BODY" | jq -r '.error.message // empty')
          
          if [ -n "$ERROR_MESSAGE" ]; then
            echo "::warning::OpenAI API error: $ERROR_MESSAGE"
            SUMMARY=""
          else
            # Extract the summary from response
            SUMMARY=$(echo "$RESPONSE_BODY" | jq -r '.choices[0].message.content // empty')
            
            if [ -z "$SUMMARY" ]; then
              echo "::warning::Failed to generate summary using OpenAI API. Using fallback."
            else
              echo "Successfully generated summary using OpenAI API"
              if [ "${{ inputs.debug }}" = "true" ]; then
                echo "::debug::Generated summary:"
                echo "$SUMMARY"
              fi
            fi
          fi
          
          # Fallback to basic summary if LLM fails
          if [ -z "$SUMMARY" ]; then
            echo "Using fallback summary generation..."
            
            # Group commits by type (handle the new format with links)
            FEAT_COMMITS=$(echo -e "$COMMITS" | grep -E "^- (feat|feature):" || echo "")
            FIX_COMMITS=$(echo -e "$COMMITS" | grep -E "^- (fix|bugfix):" || echo "")
            BREAKING_COMMITS=$(echo -e "$COMMITS" | grep -E "^- (breaking|BREAKING CHANGE):" || echo "")
            OTHER_COMMITS=$(echo -e "$COMMITS" | grep -vE "^- (feat|feature|fix|bugfix|breaking|BREAKING CHANGE):" || echo "")
            
            # Start with highlights
            SUMMARY="### Highlights"$'\n'
            
            # Add most important items to highlights
            if [ "$BREAKING" -gt 0 ]; then
              SUMMARY="$SUMMARY- ⚠️ $BREAKING breaking change$([ "$BREAKING" -ne 1 ] && echo "s") included"$'\n'
            fi
            if [ "$FEATURES" -gt 0 ]; then
              SUMMARY="$SUMMARY- $FEATURES new feature$([ "$FEATURES" -ne 1 ] && echo "s") added"$'\n'
            fi
            if [ "$FIXES" -gt 0 ]; then
              SUMMARY="$SUMMARY- $FIXES bug fix$([ "$FIXES" -ne 1 ] && echo "es") included"$'\n'
            fi
            
            if [ -n "$FEAT_COMMITS" ]; then
              SUMMARY="$SUMMARY"$'\n\n'"### Features"$'\n'"$FEAT_COMMITS"
            fi
            
            if [ -n "$FIX_COMMITS" ]; then
              SUMMARY="$SUMMARY"$'\n\n'"### Bug Fixes"$'\n'"$FIX_COMMITS"
            fi
            
            if [ -n "$BREAKING_COMMITS" ]; then
              SUMMARY="$SUMMARY"$'\n\n'"### Breaking Changes"$'\n'"$BREAKING_COMMITS"
            fi
            
            if [ -n "$OTHER_COMMITS" ]; then
              SUMMARY="$SUMMARY"$'\n\n'"### Other Changes"$'\n'"$OTHER_COMMITS"
            fi
          fi
          
          # Save summary to output
          {
            echo 'summary<<EOF'
            echo "$SUMMARY"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"